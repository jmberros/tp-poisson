---
title: "Incendios en Cincinnati"
authors: Rognon & Duarte & Berros
output: html_notebook
---

Cargamos algunas librerías útiles:

```{r}
library(MASS)
library(tidyverse)
library(lubridate)
library(glue)
library(here)
library(gghighlight)
```

```{r}
fn <- here("data/Cincinnati_Fire_Incidents__CAD___including_EMS__ALS_BLS_.csv")

full_incidents <- read_csv(fn)

type_of_incidents <-
  full_incidents %>% count(CFD_INCIDENT_TYPE_GROUP) %>% arrange(-n)
```


```{r}

chosen_incident <- "STUCK IN ELEVATOR"
# chosen_incident <- "HEROIN OVERDOSE"
# chosen_incident <- "SUICIDE ATTEMPT"
# chosen_incident <- "NULL"

incidents <-
  full_incidents %>%
  select(
    CREATE_TIME_INCIDENT,
    CFD_INCIDENT_TYPE_GROUP) %>%
  mutate(CFD_INCIDENT_TYPE_GROUP = map_chr(CFD_INCIDENT_TYPE_GROUP,
                                           ~ifelse(is.na(.x), "NULL", .x))) %>%
  rename(
    time = CREATE_TIME_INCIDENT,
    type = CFD_INCIDENT_TYPE_GROUP) %>%
  filter(!is.na(type) & type == chosen_incident) %>%
  select(time) %>%
  mutate(time = as.POSIXct(time,
                           format = "%m/%d/%Y %I:%M:%S %p",
                           tz = "UTC")) %>%
  mutate(day = floor_date(time, "day"))
```

Exploramos el rango de tiempo:

```{r}
range <-
  incidents %>%
  summarise(
    max_date = max(time),
    min_date = min(time))

daily_incidents <-
  incidents %>%
  
  count(day) %>%
  select(n)
  
total_days <- as.integer(max(incidents$day) - min(incidents$day))

print(range)
```

Tenemos aproximadamente 3 años de datos, con `r nrow(incidents)` casos,
repartidos en `r total_days` días, de modo que vamos a agrupar por día los
datos.

Agregamos los días sin llamadas:

```{r}
missing_days <- as.integer(total_days) - nrow(daily_incidents)
daily_incidents <-
  rbind(tibble(n = rep(0, missing_days)), daily_incidents) %>%
  mutate(n = as.integer(n))
```


```{r}
daily_incidents_freq <-
  daily_incidents %>%
    count(n) %>%
    rename(count = nn) %>%
    mutate(density = count / nrow(daily_incidents))

lambda_est <- round(mean(daily_incidents$n), 2)

fig <-
  daily_incidents_freq %>%
  ggplot() +
  aes(x = n, y = density) +
  geom_point() +
  geom_line() +
  labs(title = glue("Densidad de la cantidad de {chosen_incident}"))

print(glue("El lambda estimado es: {lambda_est}"))
print(fig)
```

Calculamos $\hat{\lambda} = \bar{X}_{n} =$ `r lambda_est`. En este caso
el estimador basado en el primer momento de $X$ y el estimador de máxima
verosimilitud coinciden.

```{r}
max_n <- max(daily_incidents$n)
min_n <- min(daily_incidents$n)

fit <- fitdistr(daily_incidents$n, densfun = "negative binomial")
bn_size_est <- fit$estimate[["size"]]

known_densities <-
  tibble(
    n = seq(min_n, max_n),
    poisson = dpois(n, lambda_est),
    binomial_neg = dnbinom(x = n, size = bn_size_est, mu = lambda_est))

fig +
  geom_point(
    data = known_densities,
    aes(x = n, y = poisson), color = "RoyalBlue") +
  geom_line(
    data = known_densities,
    aes(x = n, y = poisson), color = "RoyalBlue") +
  geom_point(
     data = known_densities,
     aes(x = n, y = binomial_neg), color = "Tomato") +
  geom_line(
     data = known_densities,
     aes(x = n, y = binomial_neg), color = "Tomato")


# Wrappear todo esto con una función que acepte de input
# el nombre de un tipo de incidente
# y dé como output una lista con esta última figura y la tabla con la que
# fue generada

```














